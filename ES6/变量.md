# 声明变量

var / let / const 

- var : 全局声明。声明后,在任何区块都可以访问,和被改变,容易造成变量污染。
- let : 局部声明。它只在一个区块内有效
- const : 常量声明。常量不能变,再次赋值就报错提示

```
for (var i = 0 ;i < 3 ;i++) {
    console.log(i)    
}

console.log(i)



```

```
for (let i = 0 ; i < 3 ; i++) {
    console.log(i)
}

console.log(i)

```

for就是 let 典型的应用场景,在for循环中,我们并不喜欢变量i,在任何地方都可以被访问和改变,就希望它在循环内有效



看几个demo, 回答输出的结果是? 为什么?
1.
```
    var a = []
    
    for (let i = 0 ; i < 10 ; i++) {
        a[i] = function(){
            console.log(i)
        }
    }
    
    a[6]()


```
2.
```
    var a = []
    
    for (var i = 0 ; i < 10 ; i++) {
        a[i] = function(){
            console.log(i)
        }
    }
    
    a[6]()


```

例子1因为i是用let声明的,所以i只在本轮循环有效,每一次循环的i都是另一个全新的变量。
可是,如果每次循环的i都是新的变量,那岂不是每次i=0,如何能正常的循环呢?
这是因为JS引擎内部记忆的当前循环的次数,保证了循环可以进行。



例子2,因为i是var声明的全局变量,所以只有一个i,所有的i的值都是一个,所以最后结果为10



3.
```
 for(let i = 0 ; i < 3 ; i++){
    let i = 'abc';
    console.log(i)
 }
 
 这里的输出结果,证明了,for循环中, (let i = 0 ; i < 3 ; i++) 设置循环变量的这部分点是一个单独的父级作用域
 
 循环体内的i,是另外一个单独的子作用域

```


4.取消变量声明提升这种现象

```
    console.log(a)   // undefined ,而不是报错
    var a = 10
    
    console.log(a)   // 直接报错
    let a = 10


```

因为变量声明提升,导致还未声明的变量被使用,却不会报错,这样有些奇怪,所以进行了纠正


5.暂时性死区

```
    var tmp = 123;
    
    if(true){
        console.log(tmp)    // 直接报错
        let tmp = 'abc'
    }


```

ES6明确规定,如果一个区块内,有let或者const声明的变量,在这个区块内会变成封闭作用域,不受外部影响。

当然,你在这个作用域里,出现还未let声明就打印的状况,会报错,因为let声明之前的地方,都是 tmp的"死区"



一些不明显的死区
(1)
```
有一些死区不太明显,但是要时刻记住, 一个变量没有被声明之前,都不应该被使用

 function bar( x = y , y = 2) {
    
    return [x,y]
    
 }
 
 bar();   // 直接报错
 
 
 
 因为 x=y,这里赋值时,y还没有被声明

```
(2)
```
    var x = x  // 不报错
    
    let x = x   // 报错,因为在赋值的时候,还没有声明X

```


6.不允许重复声明


明显的重复声明

```
    function fn(){
        
        let a = 1;
        let a = 2;
    
    }

    fn()
```

不明显的重复声明例子

```
    function fn(a){
        let a
    }


    fn()

    (a)和{}是属于同一个作用域的,等于进行了重复声明
    

```

7.为什么需要区块作用域

两种场景:

(1) 内部的变量覆盖外部变量

```
        var a = 10

    function fn(){
        console.log(a)
                
        if(fasle){
            var a = 20
        }

    }
    
    fn()


```


(2) 用来循环计数的变量,泄露到外面成为全局变量

```
    for(var i=  0 ;i < 10 ; i++){
        
    }
    
    console.log(i)
    
    留下的全局变量i,可能会污染全局变量
    
    

```

实际上,块级作用域的出现,导致立即执行函数,不在必要了

8. const的本质,并不是变量的值不会改变。如果是复杂数据类型,它只能保证变量的指针不被改变,但是指针对应的数据结构可能会改变

```
const a = {name:'lzw'}
 
const a = 1 // 报错
 
a.name = '吕子威'    // 改变数据结构不会报错


如果想保证内存空间里存储的那个对象不变,需要Object.freeze({});


例如:
const foo = Object.freeze({});
// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;

```

``
9. ES6 一共有6中声明变量的方法

ES5 只有 var  和 function

ES6 有let const ,以及后面的import 和 class


10.顶层对象将逐渐和全局对象脱钩

ES5中,顶层对象window的属性,是等价于全局变量的,这被认为是JS最大的败笔之一

因为:
- 它导致只能在运行时报变量未声明的错,而无法再编译时就报出这个错误,因为全局变量可能是挂在到顶级对象上的,而顶级对象的属性是动态变化的
- window的属性是可以随便读写的,这不利用模块化编程,让程序员轻易创建全局对象。
- window表示浏览器对象,顶层对象是一个有实体含义的对象,是有问题的


所以ES6中,用let const class声明的变量,都不再是挂在window上的属性

```
var a = 123
console.log(window.a);    //123



let a = 123
console.log(window.a);   // undefined
```


10.


顶级对象:

在浏览器里window是顶级对象,但是Node里没有。

目前有一个提出方案,是让将顶级对象统一改为global

