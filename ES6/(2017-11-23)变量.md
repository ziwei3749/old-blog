# ES6 - 声明变量
- [1.let在for循环中的应用](#1)
- [2.const的本质](#2)
- [3.let和const的取消变量提升 以及 暂时性死区](#3)
- [4.let和const的不能重复声明](#4)
- [5.let和const声明的全局变量,与window这类顶级对象脱钩](#5)
- [6.ES6新增加了块级作用域,一共有6种声明方式](#6)

### <a name= "1">1.let在for循环中的应用</a>

let声明的变量,跟var的全局声明不同,属于局部声明。
let声明变量,在for循环的场景下,十分适用。

例子1: 这个例子,要注意,let声明的变量既然都是新的,但是能正常循环,是由于JS引擎可以记忆当前是第几次循环
```
    var a = [];
    for (var i = 0 ; i < 10 ; i++) {
        a[i] = function(){
            console.log(i)
        }
    }

 // 10
````

```
    var a = [];
    for (let i = 0 ; i < 10 ; i++) {
        a[i] = function(){
            console.log(i)
        }
    }


// 6
````

例子2: 这个例子,可以看到设置循环的代码部分,跟循环体,{}内,是2个不一样的作用域。

```
    for(let i = 0 ; i < 10 ; i++){
        let i = 'aaa'
        console.log(i)
    }

    // 这里如果(let i = 0 ; i < 10 ; i++)和{}内的代码是一个作用域,那么就会报错。
    不报错说明,他们是属于不同作用域
```

### <a name= "2">2.const的本质</a>

const是常量,如果用const声明后的变量,再次被赋值会报错。

但本质上,不是变量的值永远不变。例如变量是复杂数据类型时,指针不会变,指针对应的内存空间,数据结构可以被改变

````
    const a = {name:'lvziwei'}
    a = 1    // 报错
    
    a.age = 18     // 并不会报错,如果要保证对象的值不变,可以用Object.freeze({})  冻结对象

````


### <a name= "3">3.let和const的取消变量提升 以及 暂时性死区</a>

取消变量提升是指,用var会出现变量在被声明之前,就被打印,却没有报错,打印出undefined的情况(这种情况很不合理)
当我们改用let或者const声明的变量后,如果变量没有被声明就去使用,一定会报错
```
    console.log(a)   // 打印undefined
    var a = 1
    
```


暂时性死区,指的是,在一个{}块级作用域里,用let和const声明过的变量,会形成封闭作用域,不会受到外部影响
例子1:
```
    let a = 123
    
    if (true) {
        console.log(a)
        
        let a = 'lvziwei'
    }

// 由于用let存在,所以在{}内形成了封闭作用域, a变量在被声明之前就被使用了,因此会报错

// 在被声明之前的部分,都是"死区"
```

不明显的死区例子2:

```
function fn(x = y, y = 2) {
    return 1
}

fn()

// 因为 把y赋值给x时, y还没有被声明
```

例子3:

```
    let x = x
    
    // 从右向左,把x赋值给x的时候,x还没有被声明
```

### <a name= "4">4.let和const的不允许重复声明</a>

不太明显的重复声明例子:
```
    function fn(x){
       let x = 1 
    }
    
    fn()

```

### <a name= "5">5.let和const与window这类顶级对象的属性脱钩</a>

JS语言里,window这个顶级对象的属性 等同于 全局变量,这被认为是JS最大的败笔

- 它导致变量未声明的错误,只能在运行时报错,无法编译时就报错,因为全局变量可能挂在顶级对象上,而顶级对象是动态变化的
- window这个顶级对象,表示浏览器对象,而顶级对象具有实际含义是不妥的

因此用let和const声明的变量,不会挂在成为,顶级对象的属性

### <a name= "6">6.ES6新增加了块级作用域,一共有6种声明方式</a>

```
块级作用域的意义,主要在2个场景
(1) 内部变量不小心覆盖外部变量

    var a = 10
    
    function fn(){
        console.log(a)      // undefined
        if(true){
            var a = 20
        }
    }
    
    fn()
    

(2)循环后,i变量污染外部变量

    for(var i = 0 ;i<10 ; i++){
    
    }
    
    console.log(i)
    
    循环结束,外部就多了一个全局变量i,容易造成污染


```


```
ES5 一共有var function 2中声明变量的方法

ES6 还增加了 let const class import


```