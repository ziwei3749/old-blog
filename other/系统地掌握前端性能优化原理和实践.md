# 系统地掌握前端性能优化原理/实践


## 我对性能优化的理解。

我对性能优化的理解是,想做好性能优化,

- 首先要做的是搞清楚web开发从0-1到上线发布的整个环节。
- 搞清楚每一个环节后,结合自己的业务场景和团队技术栈,去找到最合适的方案。

这样做的性能优化,会比较全面系统,而且更加贴合业务实际。


举个栗子,浏览器的请求从发送到返回都经历了什么? 了解后我们可以从中发现可以优化的环节

![url](./img/url.png)

- 用户输入url给浏览器
- 浏览器可以解析出url里的域名,把域名给DNS服务器,DNS服务器会把这个域名对应的IP地址返回给浏览器
- 浏览器拿到IP地址,这样浏览器就知道需要把请求发送到什么地方去了,那ip地址就跟随着HTTP协议,包括请求参数都会进入网络中
- 经过局域网、交换机、路由器、主干网络后呢,这个请求到达服务器。
- 服务器一般是MVC的架构,controller会接受并处理这个请求,然后去调用model层,model层是负责和数据交互的,交互过程中可能会从数据库读取、操作数据,通过渲染好的view层返回给网络
- 服务端的响应经过网络,返回给浏览器后,浏览器就负责render工作嘛
- 这个浏览器的render过程呢,就会把HTML渲染成DOM树,把CSS渲染成css tree,然后根据一定的规则,合并成一个render tree,之后在去布局、绘制的过程
- 然后绘制之后再去执行JS脚本。(因为一般我们把css放在顶部,js放到底部嘛)


那么大致了解整个http请求到返回的环节,就可以从中总结一些可以优化的点,比如:

- DNS服务器是否可以通过缓存,减少DNS的查询时间?
- 之后这个网络请求中,是不是可以让请求走最近的网络环境?
- 相同的静态资源应该也可以缓存
- 我们http请求应该有很多、请求资源大小也不一样,所以可以想办法减少HTTP请求
- 减少HTTP请求的大小
- 服务端渲染
- 包括浏览器render这个过程中,涉及到重绘、回流比较消耗性能。写代码的时候要减少重绘和回流。
- 包括渲染完成后再去执行JS。其实这个已经是优化的一部分了,只不过这个不优化大家也都是这样写的。


这些就是一个http请求的过程,以及从这个过程中可以进行优化的一些点。

但是肯定也是需要结合我们公司的业务需求和技术栈来优化,才是靠谱的性能优化。因为有一些优化都是有利有弊的,比如图片相关的,转成base64、用雪碧图。


## 前端优化方式的分类

试着对性能优化的方式去进行分类:

- 构建层面
- 网络层面
- 浏览器渲染层面
- 服务器层面

注意:分类后其实也是互相有交织的。比如说我合并文件、压缩图片。这个一般算是构建层面的优化,但是也可以理解为是减少http请求和数量,也是网络层面的优化。

实际上有不少优化方式,还是跟网络会有交织。

## 最常见的前端优化方式

- 1.资源的合并和压缩
- 2.图片相关的优化
- 3.浏览器渲染机制 
    + css和js的执行加载机制
    + 懒加载和预加载
    + 重绘和回流
- 4.浏览器缓存
- 5.缓存
- 6.服务端渲染

### 1.资源的合并和压缩

资源的合并和压缩,主要用构建工具做嘛,目的基本就是减少HTTP请求的数量或者减少请求资源的体积

```
 - 1.html/css/js的压缩,还有js的混淆

 - 2.js/css文件的合并。
```
文件合并需要注意的是, 好处是请求数量、丢包问题也会少一点。
但是合并也可能产生问题:

 - 首屏渲染问题,需要加载一个超大的css文件、加载超大的js文件
 - 缓存失效。只要改动一点点代码,整个项目的缓存都是失效的。
 
 解决:
 
 - 公共代码和业务代码分开打包
 - 不同的页面划分开,单独打包。
 

### 2.图片相关的优化

```
- 1.根据业务场景,使用不同图片格式

- 2.进行图片压缩

- 3.用雪碧图减少HTTP请求 、 用转base64减少HTTP请求 、 用SVG矢量图

- 4.安卓机的话,推荐用webp
```


根据业务场景选择不同的图片格式:

- jpg : 一般用于不需要透明图片的业务场景
- png : 一般用于需要透明图片的业务场景
- webp: 用于安卓,因为IOS可能有兼容问题
- svg : 图片样式简单的我业务场景(logo icon)

注意优化方式,也要看具体情况:

- 比如base64转码,只适合小图片
- 雪碧图在减少HTTP请求的同时,也增加了一个较大资源的HTTP请求,而且如果所有图片都放到一个大图上,也会导致首屏渲染较慢。
 

### 3.浏览器渲染机制 (css和js的执行机制 、 懒加载和预加载 、重绘和回流)

浏览器的渲染机制:

```
html --> dom tree
                    --> render tree  --> 布局 --> 绘制   
css  --> css tree

```
- 从上到下顺序执行
- css会阻塞页面渲染 (因为css一改可能就会有重绘或回流)
- js也会阻塞后续的代码的执行 (JS也可能修改DOM和样式,导致重绘和回流)

```
- 1.css放到顶部,避免html先加载出来,但是没有样式。然后css加载完后突然闪烁一下页面才添加样式

- 2.js放到底部,因为优先加载页面的html/css,可以让用户尽快看到页面,JS往往都是很多,放到前面可能会导致页面加载很慢。或者你一定要把script放到前面,也可以用defer/async

- 3.关于浏览器的重绘和回流
    + 减少会触发重绘/回流的CSS属性。 比如left改用tranlaste   /  display:none 改用 opacity
    + 尽量的减少重绘/回流的次数。如果需要修改多个CSS属性,用ClassName一次性重绘/回流来写代码
    + 先隐藏dom元素(触发一次),然后你可以对他进行100次修改,在显示(再触发一次)
```


### 4.浏览器存储

```
- 1.可以用做浏览器存储的方式有:cookie / localStorage / sessionStorage / indexedDB
- 2.可以用localStorage去做客户端存储。把店铺的logo 、 名称缓存到浏览器端。下次进入时,可以提升首屏渲染的速度,不用去ajax拿数据了。
- 3.sessionStorage一般用在表单信息的维护,表单写了一半,用户不小心刷新了,可以维持数据、那如果用户把这个页面关闭了,那肯定就不维护这些数据了。
- 4.indexedDB其实用的比较少,用于存储大量结构化数据的本地数据库,可以去做app的离线版本

```

另外一个就是,可能是未来趋势的东西就是PWA和Service Worker

>PWA: 谷歌提出来的一个慨念,翻译成渐进式web app。 pwa是一些列标准,谷歌规定了一系列的检查点。

- 可靠 : 没有网络时也能提供页面访问,而不会出现'未链接网络'的页面 
- 快速 : 针对网页渲染以及网络数据访问有较好的优化
- 融入 : 应用可以被增加到手机桌面,并且和普通应用一样有全屏、推送等特性。

可以看到它是对标安卓/IOS这些的,其实就是要把web app的用户体验更进一步优化,对标移动端的app

谷歌提供了一个chrome插件lighthouse,点一下这个插件他就自己生成一份报告,帮你检查你的这个网站是否符合PWA标准。

>Service worker : 它是一个脚本,浏览器独立于当前页面,将其在后台运行

- 应用点1: 使用拦截和处理网络请求的能力,去实现一个离线应用
- 应用点2: 使用Service Worker 在后台运行同时能和页面通信的能力,去实现大规模后台数据处理


### 5.缓存优化

上面这种浏览器缓存,主要是前端来做的。还有一种缓存优化是基于HTTP协议的分级缓存策略




```
设置 分级缓存策略 来做性能优化


前2个属于强缓存 / 后2个是协商缓存
可能涉及到cache-control / expire / last-modified 或 etag

如果是cache-control设置no-store就肯定没有缓存

- expire和cache-control,后者Http1.1优先级更高,cache-control:max-age没有过期,就不会发起请求,从浏览器缓存里读取数据
- 如果max-age过期了,就会去看 last-modified 、 if-modified-since, 浏览器会发起请求,后者根据浏览器给的if-modified-since,判断资源上次修改时间。如果没变就返回304,可以继续用本地缓存。否则就200
- etag和if-modified比较相似,区别是etag优先级更高,并且它是用hash值,判断文件是否有变动。这个比根据文件修改时间更靠谱。

```


### 6.ssr服务端渲染


以前是用php渲染出html,但是这样前后段代码偶耦合,不容易维护。

但是使用react/vue这一类框架的问题是,首屏加载速度比较慢(因为他要下载vue核心代码、执行vue代码)

也就是享受前端框架带来便利的同时,也造成了首屏性能的损失,为了解决这个问题,产生了ssr服务端渲染这个做法。






